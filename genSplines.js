import { calcCubicHermiteY } from './cubicHermite.js';

// Gen control points for curves that run vertically (from 0 to height)
// and who's control points shift across x dim (via noise)
//
// Returns array of length n holding [x, y, z];
//   * x will be constant
//   * y will step linearly from 0 to height
//   * z will be generated by perlin noise seeded by x and y
const noisyControlPts = (x, n = 4, nSclX = 0.001, nSclY = 0.003, nSize = 80) => {
  const controlPts = [];
  for (let i = 0; i < n; i += 1) {
    const y = map(i, 0, n - 1, 0, height);

    const nz = noise(x * nSclX, y * nSclY);
    const z = map(nz, 0, 1, 0, -nSize);

    const controlPt = [x, y, z];
    controlPts.push(controlPt);
  }

  return controlPts;
};

// Interpolate control points outputted from `noisyControlPts()`
// See it's prolly outdated doc comments
const genSplinePts = (controlPts, nSplinePts = 100) => {
  // eslint-disable-next-line no-unused-vars
  const ctrlPts = controlPts.map(([x, y, z]) => [y, z]);

  // x assumed constant for all controlPts
  const x = controlPts[0][0];

  const splinePts = [];
  for (let i = 0; i < nSplinePts; i += 1) {
    const y = map(i, 0, nSplinePts - 1, 0, height, true);
    const yi = map(y, 0, height, 0, ctrlPts.length - 1, true);
    const z = calcCubicHermiteY(yi, ctrlPts);

    const splinePt = [x, y, z];
    splinePts.push(splinePt);
  }

  return splinePts;
};

export const genNoisySpline = (
  x, nControlPts = 4, nSplinePts = 100,
  nSclX = 0.001, nSclY = 0.003, nSize = 80,
) => {
  const controlPts = noisyControlPts(x, nControlPts, nSclX, nSclY, nSize);
  const splinePts = genSplinePts(controlPts, nSplinePts);

  return splinePts;
};
